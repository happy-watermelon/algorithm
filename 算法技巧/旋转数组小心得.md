旋转数组是二分法解决的一类问题
目前做到的题目就有剑指011,力153,154,33等

旋转数组,就是比如原数组 nums = [0,1,3,4,5,6,7]
变化后可能得到：[4,5,6,7,0,1,3]这样



主要思想是:
将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。
此时有序部分用二分法查找。
无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。
就这样循环.

如果这个数组内的元素,互不相等,这样的话相对简单一些
格式:
	int len=nums.length;
	int left=0;
	int right=len;
	int mid=0;
	while(left<=right){
		mid=lefy+((right-left)>>1);
		if(nums[mid]<nums[right]){//右侧有序,依次增大
			right=mid;//说明最小值在mid或者mid左侧,都是有可能的,所以是等于	
	}
		else if(nums[mid]<nums[right]){左侧有序,最小值在mid右边
			left=mid+1;
	}
		//因为元素互不相等,不需要考虑等于的情况
		//如果说要考虑
		//else{
			//right--;
			//}			
		 //这是为什么呢
		 //因为有可能会出现这样的情况nums={2,2,1,2,2}没办法通过上述条件来判断,到底左边有序还是右边有序
		 //通过暴力法的right--;
		 //来打破这个情况,而且是巧妙的
		
		}
		return nums[mid];
		
		如果元素是重复的,
		这里要return left或者right